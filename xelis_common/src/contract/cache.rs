use std::collections::HashMap;
use xelis_vm::Constant;
use crate::{
    versioned_type::VersionedState,
    asset::AssetData,
    crypto::{PublicKey, Hash},
};

#[derive(Debug, Clone)]
pub struct AssetChanges {
    // The asset data
    pub data: Option<(VersionedState, AssetData)>,
    // The supply of the asset
    pub supply: Option<(VersionedState, u64)>,
}

// Contract cache containing all the changes/cache made by the contract
#[derive(Debug, Clone)]
pub struct ContractCache {
    // All the transfers generated by the contract
    pub transfers: HashMap<PublicKey, HashMap<Hash, u64>>,
    // The storage of the contract
    // All the changes made by the contract are stored here
    pub storage: HashMap<Constant, (VersionedState, Option<Constant>)>,
    // The contract balances
    // Those already present are loaded due to the deposits to be added
    // If its none, it means we don't have any balance yet
    pub balances: HashMap<Hash, Option<(VersionedState, u64)>>,
    // Assets cache
    // This either contains loaded assets, or registered
    // If its none, it means we didn't found the asset in storage
    pub assets: HashMap<Hash, AssetChanges>,
    // Memory Storage
    // This is shared between all executions of the same contract
}

impl ContractCache {
    pub fn new() -> Self {
        Self {
            transfers: HashMap::new(),
            storage: HashMap::new(),
            balances: HashMap::new(),
            assets: HashMap::new()
        }
    }

    // Merge the cache with another one
    pub fn merge(&mut self, other: Self) {
        for (key, assets) in other.transfers {
            let left_assets = self.transfers.entry(key)
                .or_insert_with(HashMap::new);

            for (hash, value) in assets {
                left_assets.entry(hash)
                    .and_modify(|v| *v += value)
                    .or_insert(value);
            }
        }

        self.storage.extend(other.storage);
        self.balances.extend(other.balances);
        for (key, value) in other.assets {
            self.assets.insert(key, value);
        }
    }
}