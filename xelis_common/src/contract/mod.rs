mod metadata;
mod opaque;
mod random;
mod output;
mod provider;
mod cache;

use std::{
    any::TypeId,
    collections::{hash_map::Entry, HashMap, HashSet}
};
use anyhow::Context as AnyhowContext;
use better_any::Tid;
use indexmap::IndexMap;
use log::{debug, info};
use opaque::*;
use xelis_builder::EnvironmentBuilder;
use xelis_vm::{
    Context,
    EnvironmentError,
    FnInstance,
    FnParams,
    FnReturnType,
    OpaqueWrapper,
    Type,
    Value,
    ValueCell,
    Constant
};
use crate::{
    block::{Block, TopoHeight},
    config::{
        FEE_PER_ACCOUNT_CREATION,
        FEE_PER_BYTE_OF_EVENT_DATA
    },
    crypto::{Address, Hash, PublicKey, Signature},
    transaction::ContractDeposit,
    versioned_type::VersionedState,
    serializer::Serializer
};

pub use metadata::ContractMetadata;
pub use random::DeterministicRandom;
pub use output::*;

pub use opaque::ContractStorage;
pub use provider::*;
pub use opaque::register_opaque_types;
pub use cache::*;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TransferOutput {
    // The destination key for the transfer
    pub destination: PublicKey,
    // The amount to transfer
    pub amount: u64,
    // The asset to transfer
    pub asset: Hash,
}

pub struct ChainState<'a> {
    // Are we in debug mode
    // used by the contract to print debug information
    pub debug_mode: bool,
    // The random number generator
    // It is deterministic so we can replay the contract
    pub random: DeterministicRandom,
    // Are we in mainnet
    pub mainnet: bool,
    // The contract hash
    pub contract: &'a Hash,
    // The topoheight of the block
    pub topoheight: TopoHeight,
    // Block hash in which the contract is executed
    pub block_hash: &'a Hash,
    // The block in which the contract is executed
    pub block: &'a Block,
    // Tx hash in which the contract is executed
    pub tx_hash: &'a Hash,
    // All deposits made by the caller
    pub deposits: &'a IndexMap<Hash, ContractDeposit>,
    // The contract cache
    // If the contract was called already, we may have a cache with data
    pub cache: ContractCache,
    // The contract outputss
    // This is similar to an event log
    pub outputs: Vec<ContractOutput>,
    // The contract event tracker
    // This is used to track all the events generated by the contract
    pub tracker: ContractEventTracker,
}

// Aggregate all events from all executed contracts to track in one structure
#[derive(Debug, Clone, Default)]
pub struct ContractEventTracker {
    // All the transfers made by all contracts
    pub transfers: HashMap<PublicKey, HashMap<Hash, u64>>,
    // All assets registered by all contracts
    pub assets_created: HashSet<Hash>
}

// Build the environment for the contract
pub fn build_environment<P: ContractProvider>() -> EnvironmentBuilder<'static> {
    debug!("Building environment for contract");

    let mut env = EnvironmentBuilder::default();

    env.get_mut_function("println", None, vec![Type::Any])
        .set_on_call(println_fn);

    env.get_mut_function("debug", None, vec![Type::Any])
        .set_on_call(debug_fn);

    // Opaque type but we provide getters
    let tx_type = Type::Opaque(env.register_opaque::<OpaqueTransaction>("Transaction"));
    let hash_type = Type::Opaque(env.register_opaque::<Hash>("Hash"));
    let address_type = Type::Opaque(env.register_opaque::<Address>("Address"));
    let random_type = Type::Opaque(env.register_opaque::<OpaqueRandom>("Random"));
    let block_type = Type::Opaque(env.register_opaque::<OpaqueBlock>("Block"));
    let storage_type = Type::Opaque(env.register_opaque::<OpaqueStorage>("Storage"));
    let memory_storage_type = Type::Opaque(env.register_opaque::<OpaqueMemoryStorage>("MemoryStorage"));
    let asset_type = Type::Opaque(env.register_opaque::<Asset>("Asset"));
    let asset_manager_type = Type::Opaque(env.register_opaque::<AssetManager>("AssetManager"));
    let signature_type = Type::Opaque(env.register_opaque::<Signature>("Signature"));

    // Transaction
    {
        env.register_native_function(
            "transaction",
            None,
            vec![],
            transaction,
            5,
            Some(tx_type.clone())
        );
        env.register_native_function(
            "nonce",
            Some(tx_type.clone()),
            vec![],
            transaction_nonce,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "hash",
            Some(tx_type.clone()),
            vec![],
            transaction_hash,
            5,
            Some(hash_type.clone())
        );
        env.register_native_function(
            "source",
            Some(tx_type.clone()),
            vec![],
            transaction_source,
            5,
            Some(address_type.clone())
        );
        env.register_native_function(
            "fee",
            Some(tx_type.clone()),
            vec![],
            transaction_fee,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "signature",
            Some(tx_type.clone()),
            vec![],
            transaction_signature,
            5,
            Some(signature_type.clone())
        );
    }

    // Block
    {
        env.register_native_function(
            "block",
            None,
            vec![],
            block,
            5,
            Some(block_type.clone())
        );
        env.register_native_function(
            "nonce",
            Some(block_type.clone()),
            vec![],
            block_nonce,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "timestamp",
            Some(block_type.clone()),
            vec![],
            block_timestamp,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "height",
            Some(block_type.clone()),
            vec![],
            block_height,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "extra_nonce",
            Some(block_type.clone()),
            vec![],
            block_extra_nonce,
            5,
            Some(Type::Array(Box::new(Type::U8)))
        );
        env.register_native_function(
            "hash",
            Some(block_type.clone()),
            vec![],
            block_hash,
            5,
            Some(hash_type.clone())
        );
        env.register_native_function(
            "miner",
            Some(block_type.clone()),
            vec![],
            block_miner,
            5,
            Some(address_type.clone())
        );
        env.register_native_function(
            "version",
            Some(block_type.clone()),
            vec![],
            block_version,
            5,
            Some(Type::U8)
        );
        env.register_native_function(
            "tips",
            Some(block_type.clone()),
            vec![],
            block_tips,
            5,
            Some(Type::Array(Box::new(hash_type.clone())))
        );
    }

    // Storage
    {
        env.register_native_function(
            "storage",
            None,
            vec![],
            storage,
            5,
            Some(storage_type.clone())
        );
        env.register_native_function(
            "load",
            Some(storage_type.clone()),
            vec![("key", Type::Any)],
            storage_load::<P>,
            50,
            Some(Type::Optional(Box::new(Type::Any)))
        );
        env.register_native_function(
            "has",
            Some(storage_type.clone()),
            vec![("key", Type::Any)],
            storage_has::<P>,
            25,
            Some(Type::Bool)
        );
        env.register_native_function(
            "store",
            Some(storage_type.clone()),
            vec![("key", Type::Any), ("value", Type::Any)],
            storage_store::<P>,
            50,
            Some(Type::Optional(Box::new(Type::Any)))
        );
        env.register_native_function(
            "delete",
            Some(storage_type.clone()),
            vec![("key", Type::Any)],
            storage_delete::<P>,
            50,
            Some(Type::Optional(Box::new(Type::Any)))
        );
    }

    // Memory Storage
    {
        env.register_native_function(
            "memory_storage",
            None,
            vec![],
            memory_storage,
            5,
            Some(memory_storage_type.clone())
        );
        env.register_native_function(
            "load",
            Some(memory_storage_type.clone()),
            vec![("key", Type::Any)],
            memory_storage_load::<P>,
            50,
            Some(Type::Optional(Box::new(Type::Any)))
        );
        env.register_native_function(
            "has",
            Some(memory_storage_type.clone()),
            vec![("key", Type::Any)],
            memory_storage_has::<P>,
            25,
            Some(Type::Bool)
        );
        env.register_native_function(
            "store",
            Some(memory_storage_type.clone()),
            vec![("key", Type::Any), ("value", Type::Any)],
            memory_storage_store::<P>,
            50,
            Some(Type::Optional(Box::new(Type::Any)))
        );
        env.register_native_function(
            "delete",
            Some(memory_storage_type.clone()),
            vec![("key", Type::Any)],
            memory_storage_delete::<P>,
            50,
            Some(Type::Optional(Box::new(Type::Any)))
        );
    }

    // Address
    {
        env.register_native_function(
            "is_mainnet",
            Some(address_type.clone()),
            vec![],
            address_is_mainnet,
            5,
            Some(Type::Bool)
        );
        env.register_native_function(
            "is_normal",
            Some(address_type.clone()),
            vec![],
            address_is_normal,
            5,
            Some(Type::Bool)
        );
        env.register_native_function(
            "to_public_key_bytes",
            Some(address_type.clone()),
            vec![],
            address_public_key_bytes,
            10,
            Some(Type::Array(Box::new(Type::U8)))
        );
        env.register_static_function(
            "from_string",
            address_type.clone(),
            vec![("address", Type::String)],
            address_from_string,
            75,
            Some(address_type.clone())
        );
    }

    // Hash
    {
        env.register_native_function(
            "as_bytes",
            Some(hash_type.clone()),
            vec![],
            hash_as_bytes_fn,
            5,
            Some(Type::Array(Box::new(Type::U8)))
        );
        env.register_static_function(
            "from_bytes",
            hash_type.clone(),
            vec![("bytes", Type::Array(Box::new(Type::U8)))],
            hash_from_bytes_fn,
            75,
            Some(hash_type.clone())
        );
        env.register_static_function(
            "from_hex",
            hash_type.clone(),
            vec![("hex", Type::String)],
            hash_from_hex_fn,
            75,
            Some(hash_type.clone())
        );
        env.register_static_function(
            "blake3",
            hash_type.clone(),
            vec![("input", Type::Array(Box::new(Type::U8)))],
            blake3_fn,
            3000,
            Some(hash_type.clone())
        );
        env.register_static_function(
            "sha256",
            hash_type.clone(),
            vec![("input", Type::Array(Box::new(Type::U8)))],
            sha256_fn,
            7500,
            Some(hash_type.clone())
        );
    }

    // Random number generator
    {
        env.register_native_function(
            "random",
            None,
            vec![],
            random_fn,
            5,
            Some(random_type.clone())
        );
        env.register_native_function(
            "next_u8",
            Some(random_type.clone()),
            vec![],
            random_u8,
            5,
            Some(Type::U8)
        );
        env.register_native_function(
            "next_u16",
            Some(random_type.clone()),
            vec![],
            random_u16,
            5,
            Some(Type::U16)
        );
        env.register_native_function(
            "next_u32",
            Some(random_type.clone()),
            vec![],
            random_u32,
            5,
            Some(Type::U32)
        );
        env.register_native_function(
            "next_u64",
            Some(random_type.clone()),
            vec![],
            random_u64,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "next_u128",
            Some(random_type.clone()),
            vec![],
            random_u128,
            5,
            Some(Type::U128)
        );
        env.register_native_function(
            "next_u256",
            Some(random_type.clone()),
            vec![],
            random_u256,
            5,
            Some(Type::U256)
        );
        env.register_native_function(
            "next_bool",
            Some(random_type.clone()),
            vec![],
            random_bool,
            5,
            Some(Type::Bool)
        );
    }

    // Asset
    {
        env.register_native_function(
            "get_max_supply",
            Some(asset_type.clone()),
            vec![],
            asset_get_max_supply::<P>,
            5,
            Some(Type::Optional(Box::new(Type::U64)))
        );
        env.register_native_function(
            "get_supply",
            Some(asset_type.clone()),
            vec![],
            asset_get_supply::<P>,
            15,
            Some(Type::U64)
        );
        env.register_native_function(
            "get_name",
            Some(asset_type.clone()),
            vec![],
            asset_get_name::<P>,
            5,
            Some(Type::String)
        );
        env.register_native_function(
            "get_hash",
            Some(asset_type.clone()),
            vec![],
            asset_get_hash,
            5,
            Some(hash_type.clone())
        );
        env.register_native_function(
            "mint",
            Some(asset_type.clone()),
            vec![("amount", Type::U64)],
            asset_mint::<P>,
            500,
            Some(Type::Bool)
        );
    }

    // Asset Manager
    {
        env.register_native_function(
            "asset_manager",
            None,
            vec![],
            asset_manager,
            5,
            Some(asset_manager_type.clone())
        );

        env.register_native_function(
            "get_by_id",
            Some(asset_manager_type.clone()),
            vec![("id", Type::U64)],
            asset_manager_get_by_id::<P>,
            500,
            Some(Type::Optional(Box::new(asset_type.clone())))
        );
        env.register_native_function(
            "create",
            Some(asset_manager_type.clone()),
            vec![
                ("id", Type::U64),
                ("name", Type::String),
                ("decimals", Type::U8),
                ("max_supply", Type::Optional(Box::new(Type::U64))),
            ],
            asset_manager_create::<P>,
            1000,
            Some(Type::Optional(Box::new(asset_type.clone())))
        );
    }

    // Asset related functions
    {
        // Get the current contract hash
        env.register_native_function(
            "get_contract_hash",
            None,
            vec![],
            get_contract_hash,
            5,
            Some(hash_type.clone())
        );

        // Retrieve the deposit for the given asset
        env.register_native_function(
            "get_deposit_for_asset",
            None,
            vec![("asset", hash_type.clone())],
            get_deposit_for_asset,
            5,
            Some(Type::Optional(Box::new(Type::U64)))
        );

        // Retrieve the balance for the given asset
        env.register_native_function(
            "get_balance_for_asset",
            None,
            vec![("asset", hash_type.clone())],
            get_balance_for_asset::<P>,
            25,
            Some(Type::U64)
        );

        env.register_native_function(
            "transfer",
            None,
            vec![
                ("destination", address_type.clone()),
                ("amount", Type::U64),
                ("asset", hash_type.clone()),
            ],
            transfer::<P>,
            500,
            Some(Type::Bool)
        );

        env.register_native_function(
            "burn",
            None,
            vec![
                ("amount", Type::U64),
                ("asset", hash_type.clone()),
            ],
            burn::<P>,
            500,
            Some(Type::Bool)
        );
    }

    // Signature
    {
        env.register_native_function(
            "verify",
            Some(signature_type.clone()),
            vec![
                ("data", Type::Array(Box::new(Type::U8))),
                ("address", address_type.clone()),
            ],
            signature_verify_fn,
            500,
            Some(Type::Bool)
        );
        env.register_static_function(
            "from_bytes",
            signature_type.clone(),
            vec![("bytes", Type::Array(Box::new(Type::U8)))],
            signature_from_bytes_fn,
            75,
            Some(signature_type.clone())
        );
    }

    env.register_native_function(
        "fire_event",
        None,
        vec![
            ("id", Type::U64),
            ("data", Type::Any)
        ],
        fire_event_fn,
        250,
        None
    );

    env
}

pub fn provider_from_context<'a, 'ty, 'r, P: ContractProvider>(context: &'a mut Context<'ty, 'r>) -> Result<&'a mut P, anyhow::Error> {
    let data: &mut ContractProviderWrapper<P> = context.get_mut()
        .context("Provider not initialized")?;

    Ok(data.0)
}

pub fn from_context<'a, 'ty, 'r, P: ContractProvider>(context: &'a mut Context<'ty, 'r>) -> Result<(&'a mut P, &'a mut ChainState<'ty>), anyhow::Error> {
    let mut datas = context.get_many_mut([&ContractProviderWrapper::<P>::id(), &TypeId::of::<ChainState>()]);

    let wrapper: &mut ContractProviderWrapper<P> = datas[0]
        .take()
        .context("Contract Environment is not initialized")?
        .downcast_mut()
        .context("Contract Environment is not initialized correctly")?;

    let provider: &mut P = wrapper.0;

    let state: &mut ChainState = datas[1]
        .take()
        .context("Chain state is not initialized")?
        .downcast_mut()
        .context("Chain state is not initialized correctly")?;

    Ok((provider, state))
}

// Function helper to get the balance for the given asset
// This will first check in our current changes, then in the previous execution cache
pub fn get_balance_from_cache<'a, P: ContractProvider>(provider: &P, state: &'a mut ChainState, asset: Hash) -> Result<&'a mut Option<(VersionedState, u64)>, anyhow::Error> {
    Ok(match state.cache.balances.entry(asset.clone()) {
        Entry::Occupied(entry) => entry.into_mut(),
        Entry::Vacant(entry) => {
            let v = get_balance_from_provider(provider, state.topoheight, state.contract, &asset)?;
            entry.insert(v)
        }
    })
}

pub fn get_balance_from_provider<P: ContractProvider>(provider: &P, topoheight: TopoHeight, contract: &Hash, asset: &Hash) -> Result<Option<(VersionedState, u64)>, anyhow::Error> {
    let balance = provider.get_contract_balance_for_asset(contract, asset, topoheight)?;
    Ok(balance.map(|(topoheight, balance)| (VersionedState::FetchedAt(topoheight), balance)))
}

pub fn get_asset_from_cache<'a, P: ContractProvider>(provider: &P, state: &'a mut ChainState, asset: Hash) -> Result<&'a mut AssetChanges, anyhow::Error> {
    Ok(match state.cache.assets.entry(asset.clone()) {
        Entry::Occupied(entry) => entry.into_mut(),
        Entry::Vacant(entry) => {
            let v = get_asset_from_provider(provider, state.topoheight, &asset)?;
            entry.insert(v)
        }
    })
}

pub fn get_asset_from_provider<P: ContractProvider>(provider: &P, topoheight: TopoHeight, asset: &Hash) -> Result<AssetChanges, anyhow::Error> {
    let data = provider.load_asset_data(asset, topoheight)?
        .map(|(topoheight, data)| (VersionedState::FetchedAt(topoheight), data));

    Ok(AssetChanges {
        data,
        supply: None
    })
}

fn fire_event_fn(_: FnInstance, mut params: FnParams, context: &mut Context) -> FnReturnType {
    let data = params.remove(1);
    let id = params.remove(0)
        .as_u64()?;

    let constant: Constant = data.into_owned()
        .try_into()
        .map_err(|_| EnvironmentError::InvalidParameter)?;

    let size = constant.size();
    let cost = FEE_PER_BYTE_OF_EVENT_DATA * size as u64;
    context.increase_gas_usage(cost)?;

    let state: &mut ChainState = context.get_mut().context("chain state not found")?;
    let entry = state.cache.events.entry(id)
        .or_insert_with(Vec::new);

    entry.push(constant);

    Ok(None)
}

fn println_fn(_: FnInstance, params: FnParams, context: &mut Context) -> FnReturnType {
    let state: &ChainState = context.get().context("chain state not found")?;
    if state.debug_mode {
        info!("[{}]: {}", state.contract, params[0].as_ref());
    }

    Ok(None)
}

fn debug_fn(_: FnInstance, params: FnParams, context: &mut Context) -> FnReturnType {
    let state: &ChainState = context.get().context("chain state not found")?;
    if state.debug_mode {
        debug!("{:?}", params[0].as_ref().as_value());
    }

    Ok(None)
}

fn get_contract_hash(_: FnInstance, _: FnParams, context: &mut Context) -> FnReturnType {
    let state: &ChainState = context.get().context("chain state not found")?;
    Ok(Some(Value::Opaque(OpaqueWrapper::new(state.contract.clone())).into()))
}

fn get_deposit_for_asset(_: FnInstance, params: FnParams, context: &mut Context) -> FnReturnType {
    let param = params[0].as_ref();
    let asset: &Hash = param
        .as_value()
        .as_opaque_type()
        .context("invalid asset")?;

    let chain_state: &ChainState = context.get().context("chain state not found")?;

    let mut opt = None;
    if let Some(ContractDeposit::Public(amount)) = chain_state.deposits.get(asset) {
        opt = Some(Value::U64(*amount).into());
    }

    Ok(Some(ValueCell::Optional(opt)))
}

fn get_balance_for_asset<P: ContractProvider>(_: FnInstance, mut params: FnParams, context: &mut Context) -> FnReturnType {
    let (provider, state) = from_context::<P>(context)?;

    let asset: Hash = params.remove(0)
        .into_owned()
        .into_opaque_type()?;

    let balance = get_balance_from_cache(provider, state, asset)?;

    Ok(Some(ValueCell::Optional(balance.map(|(_, v)| Value::U64(v).into()))))
}

fn transfer<P: ContractProvider>(_: FnInstance, mut params: FnParams, context: &mut Context) -> FnReturnType {
    debug!("Transfer called {:?}", params);

    let asset: Hash = params.remove(2)
        .into_owned()
        .into_opaque_type()?;

    let amount = params.remove(1)
        .into_owned()
        .to_u64()?;

    let destination: Address = params.remove(0)
        .into_owned()
        .into_opaque_type()?;

    if !destination.is_normal() {
        return Ok(Some(Value::Boolean(false).into()));
    }

    {
        let (provider, chain_state) = from_context::<P>(context)?;
        // verify that the address is well registered, otherwise: pay extra fees
        if !provider.account_exists(destination.get_public_key(), chain_state.topoheight)? {
            context.increase_gas_usage(FEE_PER_ACCOUNT_CREATION)?;
        }
    }

    let (provider, state) = from_context::<P>(context)?;
    if destination.is_mainnet() != state.mainnet {
        return Ok(Some(Value::Boolean(false).into()));
    }

    let Some((mut balance_state, mut balance)) = get_balance_from_cache(provider, state, asset.clone())? else {
        return Ok(Some(Value::Boolean(false).into()));
    };

    // We have to check if the contract has enough balance to transfer
    if balance < amount || amount == 0 {
        return Ok(Some(Value::Boolean(false).into()));
    }

    // Update the balance
    balance -= amount;
    balance_state.mark_updated();

    state.cache.balances.insert(asset.clone(), Some((balance_state, balance)));

    let key = destination.to_public_key();
    state.tracker.transfers.entry(key.clone())
        .or_insert_with(HashMap::new)
        .entry(asset.clone())
        .and_modify(|v| *v += amount)
        .or_insert(amount);

    // Add the output
    state.outputs.push(ContractOutput::Transfer { destination: key, amount, asset });

    Ok(Some(Value::Boolean(true).into()))
}

fn burn<P: ContractProvider>(_: FnInstance, mut params: FnParams, context: &mut Context) -> FnReturnType {
    let (provider, state) = from_context::<P>(context)?;

    let asset: Hash = params.remove(1)
        .into_owned()
        .into_opaque_type()?;
    let amount = params.remove(0)
        .into_owned()
        .to_u64()?;

    let Some((mut balance_state, mut balance)) = get_balance_from_cache(provider, state, asset.clone())? else {
        return Ok(Some(Value::Boolean(false).into()));
    };

    // We have to check if the contract has enough balance to transfer
    if balance < amount || amount == 0 {
        return Ok(Some(Value::Boolean(false).into()));
    }

    // Update the balance
    // By only decreasing the balance, it will be burned
    balance -= amount;
    balance_state.mark_updated();

    state.cache.balances.insert(asset.clone(), Some((balance_state, balance)));

    // Add the output
    state.outputs.push(ContractOutput::Burn { asset, amount });

    Ok(Some(Value::Boolean(true).into()))
}