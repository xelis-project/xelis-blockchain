mod metadata;
mod opaque;
mod random;
mod output;
mod provider;

use std::{any::TypeId, collections::{hash_map::Entry, HashMap}};
use anyhow::Context as AnyhowContext;
use better_any::Tid;
use indexmap::IndexMap;
use log::{debug, info};
use opaque::*;
use xelis_builder::EnvironmentBuilder;
use xelis_vm::{
    Constant,
    Context,
    FnInstance,
    FnParams,
    FnReturnType,
    OpaqueWrapper,
    Type,
    Value,
    ValueCell
};
use crate::{
    block::{Block, TopoHeight},
    crypto::{Address, Hash, PublicKey},
    transaction::ContractDeposit,
    versioned_type::VersionedState
};

pub use metadata::ContractMetadata;
pub use random::DeterministicRandom;
pub use output::*;

pub use opaque::ContractStorage;
pub use provider::*;
pub use opaque::register_opaque_types;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TransferOutput {
    // The destination key for the transfer
    pub destination: PublicKey,
    // The amount to transfer
    pub amount: u64,
    // The asset to transfer
    pub asset: Hash,
}

pub struct ChainState<'a> {
    // Are we in debug mode
    // used by the contract to print debug information
    pub debug_mode: bool,
    // The random number generator
    // It is deterministic so we can replay the contract
    pub random: DeterministicRandom,
    // Are we in mainnet
    pub mainnet: bool,
    // The contract hash
    pub contract: &'a Hash,
    // The topoheight of the block
    pub topoheight: TopoHeight,
    // Block hash in which the contract is executed
    pub block_hash: &'a Hash,
    // The block in which the contract is executed
    pub block: &'a Block,
    // Tx hash in which the contract is executed
    pub tx_hash: &'a Hash,
    // All deposits made by the caller
    pub deposits: &'a IndexMap<Hash, ContractDeposit>,
    // The contract cache
    // If the contract was called already, we may have a cache
    pub cache: Option<&'a ContractCache>,
    // The contract changes that occured during the execution
    // If the contract exit correctly, these changes are merged into above cache
    pub changes: ContractCache,
}

// Contract cache containing all the changes/cache made by the contract
#[derive(Debug, Clone)]
pub struct ContractCache {
    // All the transfers generated by the contract
    pub transfers: Vec<TransferOutput>,
    // The storage of the contract
    // All the changes made by the contract are stored here
    pub storage: HashMap<Constant, (VersionedState, Option<Constant>)>,
    // The contract balances
    // Those already present are loaded due to the deposits to be added
    // If its none, it means we don't have any balance yet
    pub balances: HashMap<Hash, Option<(VersionedState, u64)>>,
}

impl ContractCache {
    pub fn new() -> Self {
        Self {
            transfers: Vec::new(),
            storage: HashMap::new(),
            balances: HashMap::new(),
        }
    }

    // Merge the cache with another one
    pub fn merge(&mut self, other: Self) {
        self.transfers.extend(other.transfers);
        self.storage.extend(other.storage);
        self.balances.extend(other.balances);
    }
}

// Build the environment for the contract
pub fn build_environment<P: ContractProvider>() -> EnvironmentBuilder<'static> {
    debug!("Building environment for contract");
    register_opaque_types();

    let mut env = EnvironmentBuilder::default();

    env.get_mut_function("println", None, vec![Type::Any])
        .set_on_call(println_fn);

    env.get_mut_function("debug", None, vec![Type::Any])
        .set_on_call(debug_fn);

    // Opaque type but we provide getters
    let tx_type = Type::Opaque(env.register_opaque::<OpaqueTransaction>("Transaction"));
    let hash_type = Type::Opaque(env.register_opaque::<Hash>("Hash"));
    let address_type = Type::Opaque(env.register_opaque::<Address>("Address"));
    let random_type = Type::Opaque(env.register_opaque::<OpaqueRandom>("Random"));
    let block_type = Type::Opaque(env.register_opaque::<OpaqueBlock>("Block"));
    let storage_type = Type::Opaque(env.register_opaque::<OpaqueStorage>("Storage"));

    // Transaction
    {
        env.register_native_function(
            "transaction",
            None,
            vec![],
            transaction,
            5,
            Some(tx_type.clone())
        );
        env.register_native_function(
            "nonce",
            Some(tx_type.clone()),
            vec![],
            transaction_nonce,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "hash",
            Some(tx_type.clone()),
            vec![],
            transaction_hash,
            5,
            Some(hash_type.clone())
        );
        env.register_native_function(
            "source",
            Some(tx_type.clone()),
            vec![],
            transaction_source,
            5,
            Some(address_type.clone())
        );
        env.register_native_function(
            "fee",
            Some(tx_type.clone()),
            vec![],
            transaction_fee,
            5,
            Some(Type::U64)
        );
    }

    // Block
    {
        env.register_native_function(
            "block",
            None,
            vec![],
            block,
            5,
            Some(block_type.clone())
        );
        env.register_native_function(
            "nonce",
            Some(block_type.clone()),
            vec![],
            block_nonce,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "timestamp",
            Some(block_type.clone()),
            vec![],
            block_timestamp,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "height",
            Some(block_type.clone()),
            vec![],
            block_height,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "extra_nonce",
            Some(block_type.clone()),
            vec![],
            block_extra_nonce,
            5,
            Some(Type::Array(Box::new(Type::U8)))
        );
        env.register_native_function(
            "hash",
            Some(block_type.clone()),
            vec![],
            block_hash,
            5,
            Some(hash_type.clone())
        );
        env.register_native_function(
            "miner",
            Some(block_type.clone()),
            vec![],
            block_miner,
            5,
            Some(address_type.clone())
        );
        env.register_native_function(
            "version",
            Some(block_type.clone()),
            vec![],
            block_version,
            5,
            Some(Type::U8)
        );
        env.register_native_function(
            "tips",
            Some(block_type.clone()),
            vec![],
            block_tips,
            5,
            Some(Type::Array(Box::new(hash_type.clone())))
        );
    }

    // Storage
    {
        env.register_native_function(
            "storage",
            None,
            vec![],
            storage,
            5,
            Some(storage_type.clone())
        );
        env.register_native_function(
            "load",
            Some(storage_type.clone()),
            vec![("key", Type::Any)],
            storage_load::<P>,
            50,
            Some(Type::Optional(Box::new(Type::Any)))
        );
        env.register_native_function(
            "has",
            Some(storage_type.clone()),
            vec![("key", Type::Any)],
            storage_has::<P>,
            25,
            Some(Type::Bool)
        );
        env.register_native_function(
            "store",
            Some(storage_type.clone()),
            vec![("key", Type::Any), ("value", Type::Any)],
            storage_store::<P>,
            50,
            None
        );
        env.register_native_function(
            "delete",
            Some(storage_type.clone()),
            vec![("key", Type::Any)],
            storage_delete::<P>,
            50,
            None
        );
    }

    // Address
    {
        env.register_native_function(
            "is_mainnet",
            Some(address_type.clone()),
            vec![],
            address_is_mainnet,
            5,
            Some(Type::Bool)
        );
        env.register_native_function(
            "is_normal",
            Some(address_type.clone()),
            vec![],
            address_is_normal,
            5,
            Some(Type::Bool)
        );

        env.register_native_function(
            "to_public_key_bytes",
            Some(address_type.clone()),
            vec![],
            address_public_key_bytes,
            10,
            Some(Type::Array(Box::new(Type::U8)))
        );

        env.register_const_function(
            "from_string",
            address_type.clone(),
            vec![("address", Type::String)],
            address_from_string
        );
    }

    // Get the current contract hash
    env.register_native_function(
        "get_contract_hash",
        None,
        vec![],
        get_contract_hash,
        5,
        Some(hash_type.clone())
    );

    // Retrieve the deposit for the given asset
    env.register_native_function(
        "get_deposit_for_asset",
        None,
        vec![("asset", hash_type.clone())],
        get_deposit_for_asset,
        5,
        Some(Type::Optional(Box::new(Type::U64)))
    );

    // Retrieve the balance for the given asset
    env.register_native_function(
        "get_balance_for_asset",
        None,
        vec![("asset", hash_type.clone())],
        get_balance_for_asset::<P>,
        25,
        Some(Type::U64)
    );

    env.register_native_function(
        "transfer",
        None,
        vec![
            ("destination", address_type.clone()),
            ("amount", Type::U64),
            ("asset", hash_type.clone()),
        ],
        transfer::<P>,
        500,
        Some(Type::Bool)
    );

    env.register_native_function(
        "burn",
        None,
        vec![
            ("amount", Type::U64),
            ("asset", hash_type.clone()),
        ],
        burn::<P>,
        500,
        Some(Type::Bool)
    );

    // Hash
    {
        env.register_native_function(
            "as_bytes",
            Some(hash_type.clone()),
            vec![],
            hash_as_bytes_fn,
            5,
            Some(Type::Array(Box::new(Type::U8)))
        );

        // Const function
        env.register_const_function(
            "from_bytes",
            hash_type.clone(),
            vec![("bytes", Type::Array(Box::new(Type::U8)))],
            hash_from_bytes_fn,
        );

        env.register_const_function(
            "from_hex",
            hash_type.clone(),
            vec![("hex", Type::String)],
            hash_from_hex_fn,
        );
    }

    // Random number generator
    {
        env.register_native_function(
            "random",
            None,
            vec![],
            random_fn,
            5,
            Some(random_type.clone())
        );
        env.register_native_function(
            "next_u8",
            Some(random_type.clone()),
            vec![],
            random_u8,
            5,
            Some(Type::U8)
        );
        env.register_native_function(
            "next_u16",
            Some(random_type.clone()),
            vec![],
            random_u16,
            5,
            Some(Type::U16)
        );
        env.register_native_function(
            "next_u32",
            Some(random_type.clone()),
            vec![],
            random_u32,
            5,
            Some(Type::U32)
        );
        env.register_native_function(
            "next_u64",
            Some(random_type.clone()),
            vec![],
            random_u64,
            5,
            Some(Type::U64)
        );
        env.register_native_function(
            "next_u128",
            Some(random_type.clone()),
            vec![],
            random_u128,
            5,
            Some(Type::U128)
        );
        env.register_native_function(
            "next_u256",
            Some(random_type.clone()),
            vec![],
            random_u256,
            5,
            Some(Type::U256)
        );
        env.register_native_function(
            "next_bool",
            Some(random_type.clone()),
            vec![],
            random_bool,
            5,
            Some(Type::Bool)
        );
    }

    env
}

pub fn provider_from_context<'a, 'ty, 'r, P: ContractProvider>(context: &'a mut Context<'ty, 'r>) -> Result<&'a mut P, anyhow::Error> {
    let data: &mut ContractProviderWrapper<P> = context.get_mut()
        .context("Provider not initialized")?;

    Ok(data.0)
}

pub fn from_context<'a, 'ty, 'r, P: ContractProvider>(context: &'a mut Context<'ty, 'r>) -> Result<(&'a mut P, &'a mut ChainState<'ty>), anyhow::Error> {
    let mut datas = context.get_many_mut([&ContractProviderWrapper::<P>::id(), &TypeId::of::<ChainState>()]);

    let wrapper: &mut ContractProviderWrapper<P> = datas[0]
        .take()
        .context("Contract Environment is not initialized")?
        .downcast_mut()
        .context("Contract Environment is not initialized correctly")?;

    let provider: &mut P = wrapper.0;

    let state: &mut ChainState = datas[1]
        .take()
        .context("Chain state is not initialized")?
        .downcast_mut()
        .context("Chain state is not initialized correctly")?;

    Ok((provider, state))
}

// Function helper to get the balance for the given asset
pub fn get_balance_from_cache<P: ContractProvider>(provider: &P, state: &mut ChainState, asset: Hash) -> Result<Option<(VersionedState, u64)>, anyhow::Error> {
    Ok(match state.cache {
        Some(cache) => match cache.balances.get(&asset) {
            Some(v) => *v,
            None => *get_balance_from_changes(provider, state.contract, &mut state.changes, state.topoheight, asset)?
        },
        None => *get_balance_from_changes(provider, state.contract, &mut state.changes, state.topoheight, asset)?
    })
}

pub fn get_balance_from_changes<'a, P: ContractProvider>(provider: &P, contract: &Hash, cache: &'a mut ContractCache, topoheight: TopoHeight, asset: Hash) -> Result<&'a mut Option<(VersionedState, u64)>, anyhow::Error> {
    Ok(match cache.balances.entry(asset.clone()) {
        Entry::Occupied(entry) => entry.into_mut(),
        Entry::Vacant(entry) => {
            let balance = provider.get_contract_balance_for_asset(contract, &asset, topoheight)?;
            entry.insert(balance.map(|(topoheight, balance)| (VersionedState::FetchedAt(topoheight), balance)))
        }
    })
}

fn println_fn(_: FnInstance, params: FnParams, context: &mut Context) -> FnReturnType {
    let state: &ChainState = context.get().context("chain state not found")?;
    if state.debug_mode {
        info!("[{}]: {}", state.contract, params[0].as_ref());
    }

    Ok(None)
}

fn debug_fn(_: FnInstance, params: FnParams, context: &mut Context) -> FnReturnType {
    let state: &ChainState = context.get().context("chain state not found")?;
    if state.debug_mode {
        debug!("{:?}", params[0].as_ref().as_value());
    }

    Ok(None)
}

fn get_contract_hash(_: FnInstance, _: FnParams, context: &mut Context) -> FnReturnType {
    let state: &ChainState = context.get().context("chain state not found")?;
    Ok(Some(Value::Opaque(OpaqueWrapper::new(state.contract.clone())).into()))
}

fn get_deposit_for_asset(_: FnInstance, params: FnParams, context: &mut Context) -> FnReturnType {
    let param = params[0].as_ref();
    let asset: &Hash = param
        .as_value()
        .as_opaque_type()
        .context("invalid asset")?;

    let chain_state: &ChainState = context.get().context("chain state not found")?;

    let mut opt = None;
    if let Some(deposit) = chain_state.deposits.get(asset) {
        match deposit {
            ContractDeposit::Public(amount) => {
                opt = Some(Value::U64(*amount).into());
            }
        }
    }

    Ok(Some(ValueCell::Optional(opt)))
}

fn get_balance_for_asset<P: ContractProvider>(_: FnInstance, mut params: FnParams, context: &mut Context) -> FnReturnType {
    let (provider, state) = from_context::<P>(context)?;

    let asset: Hash = params.remove(0)
        .into_owned()
        .into_opaque_type()?;

    let balance = get_balance_from_cache(provider, state, asset)?;

    Ok(Some(ValueCell::Optional(balance.map(|(_, v)| Value::U64(v).into()))))
}

fn transfer<P: ContractProvider>(_: FnInstance, mut params: FnParams, context: &mut Context) -> FnReturnType {
    let (provider, state) = from_context::<P>(context)?;

    let amount = params.remove(2)
        .into_owned()
        .to_u64()?;

    let asset: Hash = params.remove(1)
        .into_owned()
        .into_opaque_type()?;

    let destination: Address = params.remove(0)
        .into_owned()
        .into_opaque_type()?;

    if !destination.is_normal() {
        return Ok(Some(Value::Boolean(false).into()));
    }

    if destination.is_mainnet() != state.mainnet {
        return Ok(Some(Value::Boolean(false).into()));
    }

    // TODO: verify that the address is well registered, otherwise: pay extra fees

    let Some((mut balance_state, mut balance)) = get_balance_from_cache(provider, state, asset.clone())? else {
        return Ok(Some(Value::Boolean(false).into()));
    };

    // We have to check if the contract has enough balance to transfer
    if balance < amount || amount == 0 {
        return Ok(Some(Value::Boolean(false).into()));
    }

    // Update the balance
    balance -= amount;
    balance_state.mark_updated();

    state.changes.balances.insert(asset.clone(), Some((balance_state, balance)));

    state.changes.transfers.push(TransferOutput {
        destination: destination.to_public_key(),
        amount,
        asset,
    });

    Ok(Some(Value::Boolean(true).into()))
}

fn burn<P: ContractProvider>(_: FnInstance, mut params: FnParams, context: &mut Context) -> FnReturnType {
    let (provider, state) = from_context::<P>(context)?;

    let asset: Hash = params.remove(1)
        .into_owned()
        .into_opaque_type()?;
    let amount = params.remove(0)
        .into_owned()
        .to_u64()?;

    let Some((mut balance_state, mut balance)) = get_balance_from_cache(provider, state, asset.clone())? else {
        return Ok(Some(Value::Boolean(false).into()));
    };

    // We have to check if the contract has enough balance to transfer
    if balance < amount || amount == 0 {
        return Ok(Some(Value::Boolean(false).into()));
    }

    // Update the balance
    // By only decreasing the balance, it will be burned
    balance -= amount;
    balance_state.mark_updated();

    state.changes.balances.insert(asset, Some((balance_state, balance)));

    Ok(Some(Value::Boolean(true).into()))
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_merge_cache() {
        use super::*;

        let mut cache1 = ContractCache::new();
        cache1.balances.insert(Hash::zero(), Some((VersionedState::FetchedAt(0), 100)));

        let mut cache2 = ContractCache::new();
        cache2.balances.insert(Hash::zero(), Some((VersionedState::FetchedAt(0), 200)));

        cache1.merge(cache2);

        assert_eq!(cache1.balances.len(), 1);
        assert_eq!(cache1.balances.get(&Hash::zero()), Some(&Some((VersionedState::FetchedAt(0), 200))));
    }
}